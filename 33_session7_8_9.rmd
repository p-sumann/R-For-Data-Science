---
title: '**Assignment 2: Web scrapping/Data Wrangling in R**'
author: '**Suman Paudel 33**'
date: "`r Sys.Date()`"
output:
  html_document: 
    theme: united
    highlight: tango
  pdf_document: 
    highlight: pygments
---

[GitHub Repository](https://github.com/sumanpaudel1997/R-For-Data-Science/tree/main)

### [ <b>Code Execution and Output/Interpretation of Session 7</b>]{style="color:#d30000"}

#### **What is a “package” in R?**

-   In R, the fundamental unit of shareable code/function is the package.
-   A package bundles together code, data, documentation, and tests, and is easy to share with others.
-   The public clearing house for R packages is the Comprehensive R Archive Network or `CRAN`. The details about the packages can be found at CRAN.

#### **How to install, use and get help about any package from CRAN?**

-   We can install packages of CRAN in R using: **`install.packages("packagename")`**\
    For example: **`install.packages("dplyr")`**

-   We can then use the installed packages in R using:\
    **`library(packagename)`**\
    **`e.g. library(dplyr)`**

-   We can get help on the installed packages in R using:\
    **`?packagement`** or **`help(package = "packagement")`**\
    **`e.g. ?dplyr`** OR **`help(package = "dplyr")`**

#### **How to develop a package in R?  **

\ <https://hilaryparker.com/2014/04/29/writing-an-r-package-from-scratch/>

-   Step 0: Packages you will need
-   Step 1: Creating your package directory
-   Step 2: Add functions
-   Step 3: Add documentation
-   Step 4: Process your documentation
-   Step 5: Install
-   Step 6: Make a package GitHub repo (Bonus!)
-   Step 7: Infinity- Iterate

#### **Reading (Import) data in R/R Studio:**

-   Text files: R base, readr etc
-   Excel files: readXL, openxls etc.
-   SPSS, Stata, SAS files: foreign, haven etc.

#### **Reading data in R/R Studio**

-   JSON files: rjason, jsonlite, RJSONIO etc.

#### **To install the library to work on josn files.**
-   `install.packages('jsonlite')`
-   `install.packages('rjson')`

##### <span style="color:#7b9a26"> <b> Code Sample 1</b></span>

```{r}
# vector 
library("rjson")
data <- fromJSON(file = "jason_data.json")
data
```

***Interpretation***:

-   loaded the `jason_data.json` file from current working directory using rjson library.

##### <span style="color:#7b9a26"> <b> Code Sample 2</b></span>

```{r}
# covert to data frame:
jason_data_frame <- as.data.frame(data)
jason_data_frame
```

***Interpretation***:

-   converted the loaded json data into data.frame

##### <span style="color:#7b9a26"> <b> Code Sample 3</b></span>

```{r}
# summary of jason_data_frame
summary(jason_data_frame)
```

***Interpretation***:

-   summarizes the json data frame.

##### <span style="color:#7b9a26"> <b> Code Sample 4</b></span>

```{r}
# histogram of salary of jason data frame
# since salary was of character so hist was not produced, so I converted it to integer.
jason_data_frame$Salary <- as.integer(jason_data_frame$Salary)
hist(jason_data_frame$Salary)
```

***Interpretation***:

- since salary was of character so hist was not produced, so I converted it to integer.
- generates histogram of salary of jason data frame

##### <span style="color:#7b9a26"> <b> Code Sample 5</b></span>

```{r}
# average salary by department
aggregate(Salary ~ Dept, data = jason_data_frame, FUN = mean)
```

***Interpretation***:

- aggregates the average salary by department.

##### <span style="color:#7b9a26"> <b> Code Sample 6</b></span>

```{r}
# also using dplyr package
library(dplyr)
library(magrittr)
avg_by_dept <-
  jason_data_frame %>%
  group_by(Dept) %>%
  summarise(avg_salart = mean(Salary))
```

***Interpretation***:

- average salary by department can be achieved by using dplyr package and using summarise.

##### <span style="color:#7b9a26"> <b> Code Sample 7</b></span>

```{r}
# frequency distribution of all variables
# since tables only shows the frequency distribution of factors, table on numerical or integer value is bad practice.
table(jason_data_frame$Dept)
```

***Interpretation***:

- since tables only shows the frequency distribution of factors, table on numerical or integer value is bad practice.


#### **Reading JSON file from URL: Web API**

\

##### <span style="color:#7b9a26"> <b> Code Sample 8</b></span>

```{r cache=TRUE}
# fetch the data from web api
library(jsonlite)
raw <-
  fromJSON(
    "https://data.ny.gov/api/views/9a8c-vfzj/rows.json?accessType=DOWNLOAD")
food_market <- raw[['data']] 
```

***Interpretation***:

- read the json data from API using jsonlite library
- the raw object gets the list of values from where data part is extracted and assigned to food_market object

##### <span style="color:#7b9a26"> <b> Code Sample 9</b></span>

```{r}
# structure and head of food market
str(food_market) 
head(food_market, n = 4)
```

***Interpretation***:

- returns the structure and head of food_market.

##### <span style="color:#7b9a26"> <b> Code Sample 10</b></span>

```{r}
names <- food_market[,14]
```

***Interpretation***:

- returns the names stores listed in index 14 of food_market in names object

##### <span style="color:#7b9a26"> <b> Code Sample 11</b></span>

```{r}
head(names)
head(table(names), n = 7)
```

***Interpretation***:

- `head(names)` returns first few data.
- `head(table(names), n = 7)` returns the frequency table of names of stores.
- since data is so much I restricted to first 7 values for frequency table.

##### <span style="color:#7b9a26"> <b> Code Sample 12</b></span>

```{r error=TRUE}
table(v19)
```

***Interpretation***:

- trying to get the frequency tabke v19. but v19 doesn't exist and throws error

##### <span style="color:#7b9a26"> <b> Code Sample 13</b></span>

```{r error=TRUE}
table(food_market$V19)
```

***Interpretation***:

- An atomic vector is a one-dimensional data object created using functions like c() or vector() in R.
- The $ operator is commonly used to access elements of a data frame by column name.
- since food_market is of atomic vectors type, while access the element using $ returned this error.
- this can be mitigated by using `table(food_market[,19])`

##### <span style="color:#7b9a26"> <b> Code Sample 14</b></span>

```{r, warning=FALSE}
head(table(food_market[, 19]), n = 5)
```

***Interpretation***:

- returns the frequency table of data that is at 19th column of food_market
- since data is too much, I restricted the display to 5.

#### **Web scrapping in R: A Simple (barebones) Example**


##### <span style="color:#7b9a26"> <b> Code Sample 15</b></span>

```{r warning=FALSE}
# The recommended package for web scrapping in R is “rvest
# using html
library(rvest)
simple <-
  read_html('https://dataquestio.github.io/web-scraping-pages/simple.html')
simple %>% html_nodes('p') %>% html_text()
```

***Interpretation***:

- reads the html using `read_html()`
- we loaded the html in simple object then using pipes parsed the html with node 'p' then converted that to normal text.

##### <span style="color:#7b9a26"> <b> Code Sample 16</b></span>

```{r}
# Wikipedia Nepal Covid 19 
wiki_link <- "https://en.wikipedia.org/wiki/COVID-19_pandemic_in_Nepal"
wiki_page <- read_html(wiki_link)
```

***Interpretation***:

- since salary was of character so hist was not produced, so I converted it to integer.
- generates histogram of salary of jason data frame

##### <span style="color:#7b9a26"> <b> Code Sample 17</b></span>

```{r}
str(wiki_page)
```

***Interpretation***:

- structure of wiki page, returns list of 2 xml node and xml doc

##### <span style="color:#7b9a26"> <b> Code Sample 18</b></span>

```{r}
wiki_page %>% html_nodes("table")
```

***Interpretation***:

- parses the html nodes containing `table` in html page of wiki_page.

##### <span style="color:#7b9a26"> <b> Code Sample 19</b></span>

```{r}
covid_table <-
  wiki_page %>% html_elements('.COVID-19_pandemic_data_Nepal_medical_cases') %>% html_node('table') %>% html_table()
covid_table <- covid_table[[1]]
```

***Interpretation***:

- from wiki page, first parsed the html elements having `.COVID-19_pandemic_data_Nepal_medical_cases`
- then extracted the node containing `table` into html_table()
- since the data was returned in the list, the actual data was at first index which is dataframe.

#### **Data wrangling: Part I Column names of covid_table**

##### <span style="color:#7b9a26"> <b> Code Sample 20</b></span>

```{r}
names(covid_table) <-
  paste(names(covid_table), covid_table[1, ], sep = "_")
covid_table <- covid_table[-1, ]
names(covid_table)
```

***Interpretation***:

- even though the data was extracted to dataframe there was error in columns and we want to rename it
- concatenated the column names with first row of dataframe.
- and finally dropping the first column.

##### <span style="color:#7b9a26"> <b> Code Sample 21</b></span>

```{r}
#Check the structure of data again
str(covid_table)
```

***Interpretation***:

- checking the structure again to ensure.

#### **Data wrangling: Part II Renaming the column names**
- Change “Date_Date” variable as **“Date”**
- Change “Confirmed cases_Total” variable as **“Confirmed_Cases_Total”**
- Change “Confirmed cases_New” variable as **“Confirmed_Cases_New”**
- Change “Confirmed cases_Active” variable as **“Confirmed_Cases_Active”**
- Change “RT-PCR tests_Total” variable as **“RT-PCR_tests_Total”**
- Change “RT-PCR tests_New” variable as **“RT-PCR_tests_New”**
- Change “TPR_TPR” variable as **“TPR”**
- Change “RR_RR” variable as **“RR”**
- Change “CFR_CFR” variable as **“CFR”**
- Change “Ref. _Ref.” variable as **“Ref”**

##### <span style="color:#7b9a26"> <b> Code Sample 22</b></span>

```{r}
colnames(covid_table) <- c(
  "Date",
  "Confirmed_Cases_Total",
  "Confirmed_Cases_New",
  "Confirmed_Cases_Active",
  "Recoveries_Total",
  "Recoveries_New",
  "Deaths_Total",
  "Deaths_New",
  "PCR_Total",
  "PCR_New",
  "TPR",
  "RR",
  "CFR",
  "Ref"
)
```

***Interpretation***:

- renaming the column names to desired column names.

##### <span style="color:#7b9a26"> <b> Code Sample 23</b></span>

```{r}
colnames(covid_table) <- c(
  "Date",
  "Confirmed_Cases_Total",
  "Confirmed_Cases_New",
  "Confirmed_Cases_Active",
  "Recoveries_Total",
  "Recoveries_New",
  "Deaths_Total",
  "Deaths_New",
  "PCR_Total",
  "PCR_New",
  "TPR",
  "RR",
  "CFR",
  "Ref"
)
```

***Interpretation***:

- renaming the column names to desired column names.

##### <span style="color:#7b9a26"> <b> Code Sample 24</b></span>

```{r eval=FALSE}
# another way to do same thing 

names(covid_table)[names(covid_table)=='Date_Date'] = 'Date'
names(covid_table)[names(covid_table)=='Confirmed cases_Total'] = 'Confirmed_Cases_Total'
names(covid_table)[names(covid_table)=='Confirmed cases_New'] = 'Confirmed_Cases_New'
names(covid_table)[names(covid_table)=='Confirmed cases_Active'] = 'Confirmed_Cases_Active'
names(covid_table)[names(covid_table)=='Recoveries_Total'] = 'Recoveries_Total'
names(covid_table)[names(covid_table)=='Recoveries_New'] = 'Recoveries_New'
names(covid_table)[names(covid_table)=='Deaths_Total'] = 'Deaths_Total'
names(covid_table)[names(covid_table)=='Deaths_New'] = 'Deaths_New'
names(covid_table)[names(covid_table)=='RT-PCR tests_Total'] = 'PCR_Total'
names(covid_table)[names(covid_table)=='RT-PCR tests_New'] = 'PCR_New'
names(covid_table)[names(covid_table)=='TPR_TPR'] = 'TPR'
names(covid_table)[names(covid_table)=='RR_RR'] = 'RR'
names(covid_table)[names(covid_table)=='CFR_CFR'] = 'CFR'
names(covid_table)[names(covid_table)=='Ref._Ref.'] = 'Ref'
```

***Interpretation***:

- Another way to rename the column names to desired column names.

#### **Data Wrangling Part III**

##### <span style="color:#7b9a26"> <b> Code Sample 25</b></span>

```{r}

# removing "+" and "%" from the variables
covid_table$Confirmed_Cases_New <- gsub('[+]', '', covid_table$Confirmed_Cases_New)
covid_table$Recoveries_New <- gsub('[+]', '', covid_table$Recoveries_New)
covid_table$Deaths_New <- gsub('[+]', '', covid_table$Deaths_New)
covid_table$PCR_New <- gsub('[+]', '', covid_table$PCR_New)

covid_table$TPR <- gsub('[%]', '', covid_table$TPR)
covid_table$RR <- gsub('[%]', '', covid_table$RR)
covid_table$CFR <- gsub('[%]', '', covid_table$CFR)

```

***Interpretation***:

- cleaning the messy data using gsub.
- removing `%` and `+` from data.

##### <span style="color:#7b9a26"> <b> Code Sample 26</b></span>

```{r}
# since in pdf while converting chr to numeric or integer type coerce warning was given for invalid type.
covid_table$Confirmed_Cases_Total <- gsub('[,]', '', covid_table$Confirmed_Cases_Total)
covid_table$Confirmed_Cases_New <- gsub('[,]', '', covid_table$Confirmed_Cases_New)
covid_table$Confirmed_Cases_Active <- gsub('[,]', '', covid_table$Confirmed_Cases_Active)
covid_table$Recoveries_Total <- gsub('[,]', '', covid_table$Recoveries_Total)
covid_table$Recoveries_New <- gsub('[,]', '', covid_table$Recoveries_New)

covid_table$Deaths_Total <- gsub('[,]', '', covid_table$Deaths_Total)
covid_table$Deaths_New <- gsub('[,]', '', covid_table$Deaths_New)
covid_table$PCR_Total <- gsub('[,]', '', covid_table$PCR_Total)
covid_table$PCR_New <- gsub('[,]', '', covid_table$PCR_New)

covid_table$TPR <- gsub('[,]', '', covid_table$TPR)
covid_table$RR <- gsub('[,]', '', covid_table$RR)
covid_table$CFR <- gsub('[,]', '', covid_table$CFR)
```

***Interpretation***:

- Since while converting chr to integer type it gave some warning about coerce where values were invalid type for e.g `313,333` can't be interpreted as integer because of comma. But it is right in context of html in website. 
- removed the `,` using gsub.

#### **Data wrangling: Part IV Converting “chr” variables as numbers **

##### <span style="color:#7b9a26"> <b> Code Sample 27</b></span>

```{r}

covid_table$Confirmed_Cases_Total <- as.integer(covid_table$Confirmed_Cases_Total)
covid_table$Confirmed_Cases_New <- as.integer(covid_table$Confirmed_Cases_New)
covid_table$Confirmed_Cases_Active <- as.integer(covid_table$Confirmed_Cases_Active)
covid_table$Recoveries_Total <- as.integer(covid_table$Recoveries_Total)
covid_table$Recoveries_New <- as.integer(covid_table$Recoveries_New)

covid_table$Deaths_Total <- as.integer(covid_table$Deaths_Total)
covid_table$Deaths_New <- as.integer(covid_table$Deaths_New)
covid_table$PCR_Total <- as.integer(covid_table$PCR_Total)
covid_table$PCR_New <- as.integer(covid_table$PCR_New)

covid_table$TPR <- as.numeric(covid_table$TPR)
covid_table$RR <- as.numeric(covid_table$RR)
covid_table$CFR <- as.numeric(covid_table$CFR)
```

***Interpretation***:

- converted all of the required columns of chr type of integer or numeric type using `as.numeric()` function.

##### <span style="color:#7b9a26"> <b> Code Sample 28</b></span>

```{r}
str(covid_table)
```

***Interpretation***:

- finally check the data type.

#### **Converting Date (Assignment)**

##### <span style="color:#7b9a26"> <b> Code Sample 29</b></span>

```{r}
head(as.Date(covid_table$Date, format = "%d %b"), n = 50)
```

***Interpretation***:

- By default tries to check this format `"%Y-%m-%d"` or `"%Y/%m/%d"`for given date or string data.
- since out date column has day and month I have to use `%d` for day and `%b` for short name of month.
- returns the value in 2024 but that date is of 2020 and 2021
- In order to work around this I have made a logic below.

##### <span style="color:#7b9a26"> <b> Code Sample 30</b></span>

```{r }
# using base R date time functions

start_date_2020 <- "2020-01-23"
end_date_2020 <- "2020-12-31"

# check days diff
days_diff <-
  as.numeric(difftime(end_date_2020, start_date_2020, units = 'days')) + 1

# check difference till first n rows and insert value if condition is true return 2020 else 2021
check_year <- ifelse(1:nrow(covid_table) <= days_diff, 2020, 2021)

# format the date according to need
formatted_date <- as.Date(covid_table$Date, format = "%d %b")
formatted_date <- format(formatted_date, '-%m-%d')

# concantante the year and formated day and date
final_converted_date <- paste0(check_year, formatted_date)

# finally since concatenation returns string again convert the type into date and load the Date column of covid table
covid_table$Date <- as.Date(final_converted_date)
head(covid_table$Date)
class(covid_table$Date)
```

***Interpretation***:

- Since I know that data is of 23rd Jan 2020 to 31st May 2021.
- Also, after 31st Dec next year will arrive, so I set variable `start_date_2020 <- "2020-01-23"` and `end_date_2020 <- "2020-12-31"`.
- I calculated the difference in day from 23rd Jan to 31st Dec.
- Also data is serial in dataframe I filtered the data to 2020 and 2021 using difference in rows. Set `2020` to first 344 rows and rest `2021`.
- since `as.Date(covid_table$Date, format = "%d %b")` gave the date of 2024, I formatted the date and only got day and month.
- Finally concatenated the calulcated year with formatted day and month. 

##### <span style="color:#7b9a26"> <b> Code Sample 31</b></span>

```{r, warning=FALSE, message=FALSE}
# using lubridate
library(lubridate)

start_date_2020 <- "2020-01-23"
end_date_2020 <- "2020-12-31"

# find difference
diff <-
  (ymd(start_date_2020) %--% ymd(end_date_2020)) %/% days(1) + 1

# check difference till first n rows and insert value if condition is true return 2020 else 2021
check_year <- ifelse(1:nrow(covid_table) <= diff, 2020, 2021)

# format the date to day and month 
formatted_date <- ymd(as.Date(covid_table$Date, format = "%d %b"))

# create the date using make_date function
final_converted_date <-
  make_date(
    year = check_year,
    month = month(formatted_date),
    day = day(formatted_date)
  )
# change the Date column value with final converted date 
covid_table$Date <- final_converted_date
class(covid_table$Date)
```

***Interpretation***:

- Using lubridate to achieve the solution to given problem.


### [ <b> Code Execution and Output/Interpretation of Session 8 and 9</b>]{style="color:#d30000"}

##### <span style="color:#7b9a26"> <b> Code Sample 1</b></span>

```{r warning=FALSE, message=FALSE}
library(tidyverse)
library(magrittr)
```

```{r}
table1 <- tibble(
  country = c("Afghanistan", "Afghanistan", "Brazil", 
               "Brazil", "China", "China"),
  year = c(1999, 2000, 1999, 2000, 1999, 2000),
  cases = c(745,2666,37737,80488,212258,213766),
  population = c(19987071,20595360,172006362, 
                 174504898, 1272915272,1280428583)
)

table1
table2
table3
table4a
table4b
```

***Interpretation***:

- Exploring the few built in tables from tidyverse package.
- There are two main advantages of using tidy data:
  - There’s a general advantage to picking one consistent way of storing 
data. If you have a consistent data structure, it’s easier to learn the 
tools that work with it because they have an underlying uniformity.
  - There’s a specific advantage to placing variables in columns because it 
allows R’s vectorized nature to shine.
  - dplyr, ggplot2, and all the other packages in the tidyverse are 
designed to work with tidy data.

##### <span style="color:#7b9a26"> <b> Code Sample 2</b></span>

```{r}
# Pivoting – Longer to wider
# (To do standard statistical analysis)
table2 %>% pivot_wider(names_from = type, values_from = count)
```

***Interpretation***:

- Pivoting the `table2` from longer to wider.
- usually used for standard statistical analysis

##### <span style="color:#7b9a26"> <b> Code Sample 3</b></span>

```{r}
# Pivoting – Wider to Longer
# (To do Variance components analysis)
table4a %>%
  pivot_longer(c(`1999`, `2000`), names_to =
                 "year", values_to = "cases")
```

***Interpretation***:

- Pivoting the `table2` from  wider to longer.
- usually used for standard statistical analysis.

##### <span style="color:#7b9a26"> <b> Code Sample 4</b></span>

```{r}
# Tidy data: Separate
table3 %>% separate(rate, into = c("cases", "population"))
# OR
table3 %>% separate(rate, into = c("cases", "population"), sep = "/")
```

***Interpretation***:

- separate the value from single column to multiple columns.
- often useful when dealing with delimited values in single column.

##### <span style="color:#7b9a26"> <b> Code Sample 5</b></span>

```{r}
# Tidy data: Unite
table5 %>% unite(new, century, year)
# OR
table5 %>% unite(new, century, year, sep = "")
```

***Interpretation***:

- unites columns into one.
- opposite of separate: it combines multiple columns into a single column.

##### <span style="color:#7b9a26"> <b> Code Sample 6</b></span>

```{r}
# Missing values: Example
stocks <- tibble(
  year = c(2015, 2015, 2015, 2015, 2016, 2016, 2016),
  qtr = c( 1, 2, 3, 4, 2, 3, 4),
  return = c(1.88, 0.59, 0.35, NA, 0.92, 0.17, 2.66)
)

stocks %>% pivot_wider(names_from = year, values_from = return)
```

***Interpretation***:

- pivoted the stocks to wider to check missing values on year and return
- The return for the fourth quarter of 2015 is explicitly missing, 
because the cell where its value should be instead contains NA.
- The return for the first quarter of 2016 is implicitly missing, because it simply does not appear in the dataset.

##### <span style="color:#7b9a26"> <b> Code Sample 7</b></span>

```{r}
stocks %>%
  pivot_wider(names_from = year, values_from = return) %>%
  pivot_longer(
    cols = c(`2015`, `2016`),
    names_to = "year",
    values_to = "return",
    values_drop_na = TRUE
  )
```

***Interpretation***:

- `pivot_wider(names_from = year, values_from = return)` pivots data from longer to wider format. the date is spread out based on different years, where year is the column providing the year information, and return is the column providing return values.
- `pivot_longer()` is used to pivot data from wider to longer format. It gathers columns specified in cols into key-value pairs. Here, it specifies to gather columns 2015 and 2016 into a new column named "year", with their corresponding values into a new column named "return". The parameter values_drop_na = TRUE indicates that rows with missing values after pivoting should be dropped.

##### <span style="color:#7b9a26"> <b> Code Sample 8</b></span>

```{r}
stocks %>% complete(year, qtr)
```

***Interpretation***:

- `complete()` is used to complete a data frame with missing combinations of values. It takes columns specified in the arguments and ensures that all combinations of unique values are present in the resulting data frame. 
- here, it ensures that all combinations of values from the columns year and qtr are present in the data frame, filling in any missing combinations with NA values.

##### <span style="color:#7b9a26"> <b> Code Sample 9</b></span>

```{r}
treatment <- tribble(
~ person, ~ treatment, ~response,
"Derrick Whitmore", 1, 7,
NA, 2, 10,
NA, 3, 9,
"Katherine Burke", 1, 4
)
treatment

```

***Interpretation***:

- Create tibbles using an easier to read row-by-row layout. This is useful for small tables of data where readability is important.

##### <span style="color:#7b9a26"> <b> Code Sample 10</b></span>

```{r}
treatment %>% fill(person)
```

***Interpretation***:

- `fill(person)` fills missing values in the specified column (person in this case) with the most recent non-missing value in that column.


#### **Transform/manipulate data with “dplyr”**

###### To learn five key “dplyr” package functions that allow you to solve the vast majority of your data manipulation challenges:
- **``filter())``** function is used to subset a data frame, retaining all rows that satisfy your conditions.
- **``arrange()``**: orders the rows of a data frame by the values of selected columns.
- **``select()``**: (and optionally rename) variables in a data frame, using a concise mini-language that makes it easy to refer to variables based on their name e.g. a:f selects all columns from a on the left to f on the right) or type (e.g. where(is.numeric) selects all numeric columns).
- **``mutate()``**: creates new columns that are functions of existing variables. It can also modify (if the name is the same as an existing column) and delete columns (by setting their value to NULL). Collapse many values down to a single summary 
- **``summarise()``**: It returns one row for each combination of grouping variables; if there are no grouping variables, the output will have a single row summarizing all observations in the input. It will contain one column for each grouping variable and one column for each of the summary statistics that you have specified
- **``group_by()``**: Most data operations are done on groups defined by variables. group_by() takes an existing tbl and converts it into a grouped tbl where operations are performed "by group". ungroup() removes grouping.

##### <span style="color:#7b9a26"> <b> Code Sample 11</b></span>

```{r message=FALSE, warning=FALSE}
library(dplyr)
library(nycflights13)
flights
```

***Interpretation***:

- load the flights dataset.

#### **Filter Example**

##### <span style="color:#7b9a26"> <b> Code Sample 12</b></span>

```{r}
filter(flights, month == 1, day == 1)
```

***Interpretation***:

- filters flights datasets for all months and day equals to 1

##### <span style="color:#7b9a26"> <b> Code Sample 13</b></span>

```{r}

# filter jan1
jan1 <- filter(flights, month == 1, day == 1)
(jan1 <- filter(flights, month == 1, day == 1))

# filter dec25
dec25 <- filter(flights, day ==12 , day == 25)
(dec25 <- filter(flights, day ==12 , day == 25))
```

***Interpretation***:

- filters January 1 for all flights data.
- filters December 25 for all flights data.

##### <span style="color:#7b9a26"> <b> Code Sample 14</b></span>

```{r error=TRUE}
filter(flights, month = 1) #throws error
filter(flights, month == 1) #works fine
```

***Interpretation***:

- `filter(flights, month = 1)` will throw an error because month=1 doesn't filter but assigns the value 1 to month.
- filter(flights, month == 1) will filter the month 1.

##### <span style="color:#7b9a26"> <b> Code Sample 15</b></span>
```{r}

# valid filter to fetch only rows where the month is either November December.
filter(flights, month == 11 | month == 12)

# returns all row since 11 | 12 computes to TRUE
filter(flights, month == 11 | 12)

# valid filter to fetch only rows where the month is either November December.
nov_dec <- filter(flights, month %in% c(11, 12))
```

***Interpretation***:

- `filter(flights, month == 11 | month == 12)` fetch only rows where the month is either November December.
- `filter(flights, month == 11 | 12)` returns all row since 11 | 12 computes to TRUE, even though syntactically it returns values but it won't gives us desired output.
- `nov_dec <- filter(flights, month %in% c(11, 12))` fetch only rows where the month is either November December.

##### <span style="color:#7b9a26"> <b> Code Sample 16</b></span>

```{r}

# De Morgan's Law:
filter(flights, !(arr_delay > 120 | dep_delay > 120))
filter(flights, arr_delay <= 120, dep_delay <= 120) 
```

***Interpretation***:

- Both returns the same value: `filter(flights, !(arr_delay > 120 | dep_delay > 120))` filters all arrival and departure delayed which are not greater 120.
- `filter(flights, arr_delay <= 120, dep_delay <= 120)` filters all arrival and departure delayed which are less than or equal to 120.


###### **Arrange Example**

##### <span style="color:#7b9a26"> <b> Code Sample 17</b></span>

```{r}

# by default sorts in ascending order
arrange(flights, year, month, day)

# descending order
arrange(flights, desc(dep_delay))
```

***Interpretation***:

- `arrange(flights, year, month, day)` sorts year, month and day in ascending order.  
- `arrange(flights, year, month, day)` sorts year, month and day in descending order. 
- Missing values are always sorted at the end.


#### **Select Example**

##### <span style="color:#7b9a26"> <b> Code Sample 18</b></span>

```{r}

# Select columns by name
select(flights, year, month, day)
# Select all columns between year and day (inclusive)
select(flights, year:day)
# Select all columns except those from year to day (inclusive)
select(flights, -(year:day))
```

***Interpretation***:

- `select(flights, year, month, day)` selects year, month and day from flights.
- `select(flights, year:day)` selects all columns between year and day (inclusive) from flights.
- `select(flights, year, month, day)` selects all columns except those from year to day (inclusive).

#### **Other useful select functions**
- `flights %>% select(starts_with('d'))` #matches names beginning with d
- `flights %>% select(ends_with('e'))` #matches names ending with e
- `flights %>% select(contains('d'))` #matches names containing with d
- `flights %>% select(matches("(.)\\1"))` #matches any variables that contain repeated characters
- `flights %>% select(num_range("dest",1:15))` #matches if dest contains any -range between 1 to 15

##### <span style="color:#7b9a26"> <b> Code Sample 19</b></span>

```{r}

flights %>% select(starts_with('d')) #matches names beginning with d
flights %>% select(ends_with('e')) #matches names ending with e
flights %>% select(contains('d')) #matches names containing with d
flights %>% select(matches("(.)\\1")) #matches any variables that contain repeated characters
flights %>% select(num_range("dest",1:15)) #matches if dest contains any range between 1 to 15
```

##### <span style="color:#7b9a26"> <b> Code Sample 20</b></span>

```{r}

# rename
rename(flights, tail_num = tailnum)

# move to the start of the data frame
select(flights, time_hour, air_time, everything())

```

***Interpretation***:

- select() can be used to rename variables, but it’s rarely useful 
because it drops all of the variables not explicitly.
- so using rename(), which is a variant of select() that keeps all 
the variables that aren’t explicitly mentioned.
- Another option is to use select() in conjunction with the 
everything() helper.

#### Mutate: Example 

##### <span style="color:#7b9a26"> <b> Code Sample 21</b></span>

```{r}
flights_sml <- select(flights,
                      year:day,
                      ends_with("delay"),
                      distance,
                      air_time)
```

***Interpretation***:

- adding some variables in flights_sml from flights.

##### <span style="color:#7b9a26"> <b> Code Sample 22</b></span>

```{r}
mutate(flights_sml,
       gain = dep_delay - arr_delay,
       speed = distance / air_time * 60)
```

***Interpretation***:

- two new columns, gain and speed, is added based on existing variables in the flights_sml dataset.

##### <span style="color:#7b9a26"> <b> Code Sample 23</b></span>

```{r}

mutate(flights_sml,
       gain = dep_delay - arr_delay,
       hours = air_time / 60,
       gain_per_hour = gain / hours
)
```

***Interpretation***:

- three new columns (gain, hours, and gain_per_hour) were added based on existing variables which are computed in the flights_sml dataset.

##### <span style="color:#7b9a26"> <b> Code Sample 24</b></span>

```{r}
# transmute 
# If you only want to keep the new variables, use transmute()
transmute(
  flights,
  gain = dep_delay - arr_delay,
  hours = air_time / 60,
  gain_per_hour = gain / hours
)
```

***Interpretation***:

- three new variables (gain, hours, and gain_per_hour) based on existing variables in the flights dataset while discarding all other variables.

##### <span style="color:#7b9a26"> <b> Code Sample 25</b></span>

```{r}

transmute(flights,
          dep_time,
          hour = dep_time %/% 100,
          minute = dep_time %% 100)
```

***Interpretation***:

- this code creates two new variables (hour and minute) from the dep_time variable in the flights dataset, while still retaining the original dep_time variable in the output and discard all other columns.

##### <span style="color:#7b9a26"> <b> Code Sample 26</b></span>

```{r}

# Select columns by name
select(flights, year, month, day)
# Select all columns between year and day (inclusive)
select(flights, year:day)
# Select all columns except those from year to day (inclusive)
select(flights, -(year:day))
```

***Interpretation***:

- `select(flights, year, month, day)` selects year, month and day from flights.
- `select(flights, year:day)` selects all columns between year and day (inclusive) from flights.
- `select(flights, year, month, day)` selects all columns except those from year to day (inclusive).

#### **Summarise Example**

##### <span style="color:#7b9a26"> <b> Code Sample 27</b></span>

```{r}

summarise(flights, delay = mean(dep_delay, na.rm = TRUE))
```

***Interpretation***:

- computes the mean departure delay for the flights dataset, removing any missing values in the dep_delay column.

##### <span style="color:#7b9a26"> <b> Code Sample 28</b></span>

```{r}

summarise(flights, delay = mean(dep_delay, na.rm = TRUE))
```

***Interpretation***:

- computes the mean departure delay for the flights dataset, removing any missing values in the dep_delay column.

##### <span style="color:#7b9a26"> <b> Code Sample 29</b></span>

```{r}

summarise(flights, delay = mean(dep_delay, na.rm = TRUE))
```

***Interpretation***:

- computes the mean departure delay for the flights dataset, removing any missing values in the dep_delay column.

##### <span style="color:#7b9a26"> <b> Code Sample 30</b></span>

```{r}

summarise(flights, delay = mean(dep_delay, na.rm = TRUE))
```

***Interpretation***:

- computes the mean departure delay for the flights dataset, removing any missing values in the dep_delay column.

##### <span style="color:#7b9a26"> <b> Code Sample 31</b></span>

```{r}

summarise(flights, delay = mean(dep_delay, na.rm = TRUE))
```

***Interpretation***:

- computes the mean departure delay for the flights dataset, removing any missing values in the dep_delay column.

##### <span style="color:#7b9a26"> <b> Code Sample 32</b></span>

```{r}
by_day <- group_by(flights, year, month, day)
summarise(by_day, delay = mean(dep_delay, na.rm = TRUE))
```

***Interpretation***:

- computes the mean departure delay for each day in the dataset by grouping the data by year, month, and day, and then summarizing the grouped data by average delayed time.

##### <span style="color:#7b9a26"> <b> Code Sample 33</b></span>

```{r}

delays <- flights %>%
  group_by(dest) %>%
  summarise(
    count = n(),
    dist = mean(distance, na.rm = TRUE),
    delay = mean(arr_delay, na.rm =
                   TRUE)
  ) %>%
  filter(count > 20, dest != "HNL")
delays
```

***Interpretation***:

- computes summary statistics on flight delays, including the count of flights, the average distance, and the average arrival delay, grouped by destination. It then filters the results to exclude destinations with greater than 20 flights and the destination of Honolulu.

##### <span style="color:#7b9a26"> <b> Code Sample 34</b></span>

```{r}

flights %>%
  group_by(year, month, day) %>%
  summarise(mean = mean(dep_delay))
```

***Interpretation***:

- calculates the mean departure delay for each day by grouping the data by year, month, and day, and then summarising the grouped data.

##### <span style="color:#7b9a26"> <b> Code Sample 35</b></span>

```{r}

flights %>%
  group_by(year, month, day) %>%
  summarise(mean = mean(dep_delay, na.rm = TRUE))
```

***Interpretation***:

- calculates the mean departure delay for each day by grouping the data by year, month, and day, and then summarizing the grouped data after removing null from the data in the dep_delay column while computing the mean.

##### <span style="color:#7b9a26"> <b> Code Sample 36</b></span>

```{r}
not_cancelled <- flights %>%
  filter(!is.na(dep_delay),!is.na(arr_delay))
```

***Interpretation***:

- not_cancelled contains only flights that were not cancelled, based on the absence of missing values in the departure delay and arrival delay columns.
- `!` negates the TRUE value to FALSE and vice versa.

##### <span style="color:#7b9a26"> <b> Code Sample 37</b></span>

```{r}
not_cancelled %>%
  group_by(year, month, day) %>%
  summarise(mean =
              mean(dep_delay))
```

***Interpretation***:

- calculates the mean departure delay for each day in the not_cancelled dataset by grouping the data by year, month, and day, and then summarizing the grouped data.

##### <span style="color:#7b9a26"> <b> Code Sample 38</b></span>

```{r}
delays <- not_cancelled %>% 
  group_by(tailnum) %>% 
  summarise(
    delay = mean(arr_delay)
  )
delays
```

***Interpretation***:

- calculates the average arrival delay for each planes in the not_cancelled dataset by grouping the data by tailnum and then summarizing the grouped data.

##### <span style="color:#7b9a26"> <b> Code Sample 39</b></span>

```{r}
hist(delays$delay)
```

***Interpretation***:

- creates a histogram of the average arrival delays (delay) column.

##### <span style="color:#7b9a26"> <b> Code Sample 40</b></span>

```{r}
delays <- not_cancelled %>% 
  group_by(tailnum) %>% 
  summarise(
    delay = mean(arr_delay, 
                 na.rm = TRUE),
    n = n()
  )
hist(delays$n)
```

***Interpretation***:

- creates a histogram of the counts (n) of flights for each tailnum.

##### <span style="color:#7b9a26"> <b> Code Sample 41</b></span>

```{r}
plot(delays$n, delays$delay)
```

***Interpretation***:

- creates a scatter plot showing the relationship between the count of flights and the average arrival delay for each aircraft.
- even though creating histogram and scatter plot is good idead but if we can't make sense or interpret it, it will be useless in analysis.

##### <span style="color:#7b9a26"> <b> Code Sample 42</b></span>
```{r}
# When do the first and last flights leave each day
not_cancelled %>% 
  group_by(year, month, day) %>% 
  summarise(
    first = min(dep_time),
    last = max(dep_time)
  )
```

***Interpretation***:

- calculates the first and last departure times for each day in the not_cancelled dataset by grouping the data by year, month, and day, and then summarizing the grouped data.

##### <span style="color:#7b9a26"> <b> Code Sample 43</b></span>

```{r}
# Why is distance to some destinations more variable than to others?
not_cancelled %>% 
  group_by(dest) %>% 
  summarise(distance_sd = 
              sd(distance)) %>% 
  arrange(desc(distance_sd))
```

***Interpretation***:

- provides information about the variability of distances for each destination in the not_cancelled dataset, with destinations having higher standard deviations of distances appearing first in the resulting dataset.

##### <span style="color:#7b9a26"> <b> Code Sample 44</b></span>

```{r}
# Which destinations have the most carriers?
not_cancelled %>% 
  group_by(dest) %>% 
  summarise(carriers = 
              n_distinct(carrier)) %>% 
  arrange(desc(carriers))
```

***Interpretation***:

- summarizes the destination by most number of carriers.

##### <span style="color:#7b9a26"> <b> Code Sample 45</b></span>

```{r}
# How many flights left before 5am? (these usually indicate delayed flights from the previous day)
not_cancelled %>% 
  group_by(year, month, day) %>% 
  summarise(n_early = 
              sum(dep_time < 500))
```

***Interpretation***:

- summarizes the number of flights departing before 5:00 AM for each day in the not_cancelled dataset, grouped by year, month, and day.

##### <span style="color:#7b9a26"> <b> Code Sample 46</b></span>

```{r}
# What proportion of flights are delayed by more than an hour?
not_cancelled %>% 
  group_by(year, month, day) %>% 
  summarise(hour_prop = 
              mean(arr_delay > 60))
```

***Interpretation***:

- summarizes the proportion of flights with arrival delays exceeding 60 minutes for each day in the not_cancelled dataset, grouped by year, month, and day.

##### <span style="color:#7b9a26"> <b> Code Sample 47</b></span>

```{r}
#Find all groups bigger than a threshold:
popular_dests <- flights %>%
  group_by(dest) %>%
  filter(n() > 365)
popular_dests

head(popular_dests$dest)
tail(popular_dests$dest)
```

***Interpretation***:

- summarizes the destinations that are popular based on having more than 365 flights in the flights dataset.
- head() and tail() functions are then used to display the first and last few destinations in the popular_dests dataset, respectively.

#### **Slice function**

##### <span style="color:#7b9a26"> <b> Code Sample 48</b></span>

```{r}
#What will happen?
flights %>% slice(1L)
```

***Interpretation***:

- slice the first row of the flights dataset.

##### <span style="color:#7b9a26"> <b> Code Sample 49</b></span>

```{r}
#What will happen?
flights %>% slice(n())
```

***Interpretation***:
- slice the last row of the flights dataset.

##### <span style="color:#7b9a26"> <b> Code Sample 50</b></span>

```{r}
#What will happen?
flights %>% slice(5:n())
```

***Interpretation***:

- will slice rows from the 5th row to the last row of the flights dataset.

##### <span style="color:#7b9a26"> <b> Code Sample 51</b></span>

```{r}
#What will happen?
slice(flights,-(1:4))
```

***Interpretation***:

- will remove the first four rows from the flights dataset.

##### <span style="color:#7b9a26"> <b> Code Sample 52</b></span>

```{r}
#What will happen?
flights %>% slice_sample(n=5)
```

***Interpretation***:

- will randomly sample 5 rows from the flights dataset without replacement.

##### <span style="color:#7b9a26"> <b> Code Sample 53</b></span>

```{r}
#What will happen?
flights %>% slice_sample(n=5, replace = TRUE)
```

***Interpretation***:

- will randomly sample 5 rows from the flights dataset with replacement, meaning the same row may be selected more than once.

##### <span style="color:#7b9a26"> <b> Code Sample 55</b></span>

```{r}
#What will happen?
set.seed(123)
train_data <- flights %>% slice_sample(prop=0.8)
train_data
```

***Interpretation***:

- sets the random seed to ensure reproducibility of random sampling.
- `train_data <- flights %>% slice_sample(prop = 0.8)` creates a training dataset (train_data) by randomly sampling 80% of the rows from the flights dataset without replacement.

##### <span style="color:#7b9a26"> <b> Code Sample 56</b></span>

```{r}
test_data <- flights %>% slice_sample(prop=0.2)
test_data
```

***Interpretation***:

- sets the random seed to ensure reproducibility of random sampling.
- `test_data <- flights %>% slice_sample(prop=0.2)` creates a testing dataset (test_data) by randomly sampling 20% of the rows from the flights dataset without replacement.
